#![feature(return_position_impl_trait_in_trait)]

use rmp_serde as rmps;
use rmps::Serializer;
use serde::{Deserialize, Serialize};
use serde_derive::{Deserialize, Serialize};
use std::future::Future;
use std::pin::Pin;
use std::sync::mpsc::{sync_channel, Receiver, SyncSender};
use std::sync::Arc;
use std::task::Poll;
mod stupid_futures;
use stupid_futures::*;

pub type BasicFuture = Box<dyn Future<Output = ()> + Unpin>;

pub struct TaskNode<T: Program> {
    sender: SyncSender<(T, usize)>,
    input: Arc<[u8]>,
    output: Arc<[u8]>,
    future: BasicFuture,
    parent: usize,
    this_node: usize,
}

impl<T: Program> TaskNode<T> {
    pub fn write_output<'a, O: MorphicIO<'a>>(&mut self, o: O) -> Result<(), rmps::encode::Error> {
        o.serialize(&mut Serializer::new(
            Arc::get_mut(&mut self.output).unwrap(),
        ))
    }

    pub fn read_input<'a, I: MorphicIO<'a>>(&self) -> Result<I, rmps::decode::Error> {
        // Maybe input should be segmented, so not all parents have to be run, before we can fetch the input
        rmps::from_slice(&*self.input)
    }

    pub async fn branch(&mut self, token: T) {
        // This always needs to be invoked before read_input.
        //
        // If all awaits will result in the task being paused, and the executor continuing polling, this will be sufficient.
        // Else we will need a basic waker here.
        self.sender.send((token, self.this_node)).unwrap();
        Waker.await;
    }

    pub fn poll(&mut self) -> Poll<()> {
        Pin::new(&mut self.future).poll(unsafe { std::mem::transmute(&mut ()) })
    }
}

pub trait MorphicIO<'a>: Serialize + Deserialize<'a> {
    const SIZE: usize;
    fn local_serialize(self, buffer: &mut [u8]);
    fn local_deserialize(self, buffer: &[u8]);
}

// It could be cool if tokens could automatically be matched to ids.
// So the token trait has a function that takes a self perameter and returns a task.
// Then token should also implement PartialEq
pub trait Program: Sized {
    type Future: Future<Output = ()> + Unpin;
    fn id(&self) -> usize;
    fn from_id(id: usize) -> Self;
    fn future(&self, task_handle: &mut TaskNode<Self>) -> Self::Future;
    fn output_size(&self) -> usize;
    fn main() -> Self;
    fn uninit() -> Self;
}

pub struct Executor<T: Program> {
    queue: Receiver<(T, usize)>,
    //possible_tasks: Vec<Box<T>>,
    task_graph: Vec<TaskNode<T>>,
    memory: Vec<u8>,
}

impl<T: Program> Executor<T> {
    pub fn new() -> Self {
        let (sender, reciever) = sync_channel(1000);
        Self {
            queue: reciever,
            //possible_tasks: T::function_space(),
            task_graph: vec![TaskNode {
                sender: sender,
                input: Arc::new([]),
                output: Arc::new([]),
                future: Box::new(T::uninit().future(unsafe { std::mem::transmute(&()) })),
                parent: 0,
                this_node: 0,
            }],
            memory: vec![],
        }
    }

    pub fn main(&mut self) {
        let mut n = 0;

        'polling: loop {
            // Poll
            if self.task_graph[n].poll().is_ready() {
                println!("Finished node {n}");
                if self.task_graph[n].this_node == self.task_graph[n].parent {
                    println!("DONE! {} nodes left behind", self.task_graph.len());
                    self.task_graph.clear();
                    return;
                } else {
                    println!("Back to parent");
                    n = self.task_graph[n].parent;
                    self.task_graph.remove(n);
                    continue 'polling;
                }
            }

            n += 1;
            if n == self.task_graph.len() {
                println!("Ran out of nodes. Fetching new ones...");
                n = self.task_graph.len();
                let (token, parent) = self.queue.recv().unwrap();
                self.branch(token, parent);
            }
        }
    }

    pub fn branch(&mut self, token: T, parent: usize) {
        // I think we need to know here-ish, where to store result of task.

        let i = self.memory.len();
        self.memory.append(&mut vec![0; token.output_size()]);

        let node = TaskNode {
            sender: self.task_graph[0].sender.clone(),
            input: Arc::new([]),
            output: unsafe { std::mem::transmute(&mut self.memory[i..]) },
            future: Box::new(UninitFuture),
            parent,
            this_node: self.task_graph.len(),
        };
        self.task_graph.push(node);
        let last = self.task_graph.len() - 1;
        let node = &mut self.task_graph[last];
        let tmp = Box::new(token.future(node));
        node.future = tmp;
    }
}

#[test]
fn basic() {
    #[derive(Serialize, Deserialize)]
    enum Program {
        Main,
        A,
        B,
    }

    struct Main;
    impl<'a> Task<'a, Program> for Main {
        async fn future(&self, task_handle: &mut TaskNode<'a, Program>) {
            println!("::start");
            task_handle.branch(Program::A);
            task_handle.branch(Program::B);
            println!("::end");
        }

        fn output_size(&self) -> usize {
            0
        }
    }

    struct A;
    impl<'a> Task<'a, Program> for A {
        async fn future(&self, task_handle: &mut TaskNode<'a, Program>) {
            println!("::Main::A");
        }

        fn output_size(&self) -> usize {
            0
        }
    }

    struct B;
    impl<'a> Task<'a, Program> for B {
        async fn future(&self, task_handle: &mut TaskNode<'a, Program>) {
            println!("::Main::B");
        }

        fn output_size(&self) -> usize {
            0
        }
    }

    impl<'a> Program<'a> for Program {
        fn id(&self) -> usize {
            match self {
                Program::Main => 0,
                Program::A => 1,
                Program::B => 2,
            }
        }

        fn function_space() -> Vec<Box<dyn Task<'a, Self>>> {
            vec![]
        }

        fn main() -> Self {
            todo!()
        }
    }
}
